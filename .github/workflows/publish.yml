# Publish to PyPI
#
# Runs daily to check for new LLVM versions and automatically publish.
# Checks all major.minor versions >= 16 and publishes the latest patch for each.
#
# Manual trigger:
#   1. Go to Actions -> Publish to PyPI -> Run workflow
#   2. Optionally enter LLVM versions (comma-separated, e.g., "18.1.0,19.1.0,20.1.0")
#   3. Check "force" to re-publish if tag exists but PyPI publish failed
#   4. Click "Run workflow"
#
# Post-release versioning:
#   - First release: 19.1.5
#   - Re-release (force=true): 19.1.5.post1, 19.1.5.post2, etc.

name: Publish to PyPI

on:
  workflow_dispatch:
    inputs:
      llvm_versions:
        description: 'LLVM versions to release, comma-separated (leave empty for latest)'
        required: false
        type: string
      force:
        description: 'Force re-publish even if tag exists (use if PyPI publish failed)'
        required: false
        type: boolean
        default: false
  schedule:
    - cron: '0 10 * * *'

jobs:
  publish:
    runs-on: ubuntu-latest
    environment: pypi
    permissions:
      contents: write
      id-token: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine versions to publish
        id: versions
        run: |
          if [ -n "${{ inputs.llvm_versions }}" ]; then
            # Convert comma-separated input to space-separated
            versions=$(echo "${{ inputs.llvm_versions }}" | tr ',' ' ' | xargs)
            echo "Using manually specified versions: $versions"
          else
            # Get latest patch version for each major.minor >= 16
            versions=$(git -c 'versionsort.suffix=-' \
              ls-remote --exit-code --refs --sort='version:refname' --tags https://github.com/llvm/llvm-project 'llvmorg-*.*.*' \
              | sed 's/.*llvmorg-//' \
              | awk -F. '$1 >= 16' \
              | sort -t. -k1,1n -k2,2n -k3,3n \
              | awk -F. '{key=$1"."$2; versions[key]=$0} END {for (k in versions) print versions[k]}' \
              | sort -t. -k1,1n -k2,2n \
              | tr '\n' ' ')
            echo "Detected LLVM versions (latest patch per major.minor): $versions"
          fi
          echo "versions=$versions" >> $GITHUB_OUTPUT

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Publish each version sequentially
        id: publish
        env:
          GH_TOKEN: ${{ github.token }}
          FORCE: ${{ inputs.force }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          failed_versions=""
          published_versions=""

          for version in ${{ steps.versions.outputs.versions }}; do
            echo "::group::Processing LLVM $version"

            # Fetch latest to check for existing tags and get any new commits
            git fetch origin --tags

            # Check if we need to use post-release versioning
            post_release=0
            tag="v$version"
            display_version="$version"

            # Check for existing tags with this version
            existing_tags=$(git tag -l "v${version}" "v${version}.post*" 2>/dev/null || true)

            if [ -n "$existing_tags" ]; then
              if [ "$FORCE" != "true" ]; then
                echo "Tag v$version already exists, skipping (use force=true to re-publish)"
                echo "::endgroup::"
                continue
              fi

              echo "Tags exist but force=true, checking PyPI for post_release..."

              # Query PyPI to find highest existing post release
              pypi_versions=$(curl -sL "https://pypi.org/pypi/clang2/json" 2>/dev/null | jq -r '.releases | keys[]' 2>/dev/null || echo "")

              if echo "$pypi_versions" | grep -qE "^${version}(\.post[0-9]+)?$"; then
                # Find highest post release number
                highest_post=$(echo "$pypi_versions" | grep -E "^${version}(\.post[0-9]+)?$" | grep -oE "\.post[0-9]+" | sed 's/\.post//' | sort -n | tail -1)
                if [ -n "$highest_post" ]; then
                  post_release=$((highest_post + 1))
                else
                  # Base version exists but no post releases yet
                  post_release=1
                fi
              else
                post_release=1
              fi

              tag="v${version}.post${post_release}"
              display_version="${version}.post${post_release}"
              echo "Will publish as ${display_version}"
            fi

            # Track if this version fails
            version_failed=false

            # Pull latest changes (from previous iterations or other sources)
            if ! git pull --rebase origin master; then
              echo "::error::Failed to pull latest changes for $version"
              failed_versions="$failed_versions $version"
              echo "::endgroup::"
              continue
            fi

            # Download and compute hash
            echo "Downloading clang-${version}.src.tar.xz..."
            if ! curl -fSL "https://github.com/llvm/llvm-project/releases/download/llvmorg-${version}/clang-${version}.src.tar.xz" -o "clang-${version}.src.tar.xz"; then
              echo "::error::Failed to download LLVM $version"
              failed_versions="$failed_versions $version"
              echo "::endgroup::"
              continue
            fi

            hash=$(sha256sum "clang-${version}.src.tar.xz" | cut -d ' ' -f1)
            rm -f "clang-${version}.src.tar.xz"

            # Update version file with post_release
            {
              echo "# libclang Python bindings version configuration"
              echo "set(LLVM_VERSION $version)"
              echo "set(LLVM_SHA256 $hash)"
              echo "set(POST_RELEASE $post_release)"
            } > llvm_version.cmake
            cat llvm_version.cmake

            # Commit and tag (skip if tag already exists)
            if ! git rev-parse "$tag" >/dev/null 2>&1; then
              git add llvm_version.cmake
              git commit -m "Release $display_version"
              git tag "$tag"
              if ! git push origin HEAD:master --tags; then
                echo "::error::Failed to push tag for $version"
                failed_versions="$failed_versions $version"
                echo "::endgroup::"
                continue
              fi
            fi

            # Build
            echo "Building wheel..."
            if ! uv build; then
              echo "::error::Failed to build wheel for $version"
              failed_versions="$failed_versions $version"
              version_failed=true
            fi

            # Publish to PyPI
            if [ "$version_failed" = "false" ]; then
              echo "Publishing to PyPI..."
              if ! uv publish --trusted-publishing always; then
                echo "::error::Failed to publish $version to PyPI"
                failed_versions="$failed_versions $version"
                version_failed=true
              fi
            fi

            # Create GitHub Release
            if [ "$version_failed" = "false" ]; then
              if ! gh release view "$tag" >/dev/null 2>&1; then
                echo "Creating GitHub release for $tag"
                release_notes="LLVM $version Python bindings - https://releases.llvm.org/${version}/docs/ReleaseNotes.html"
                if ! gh release create "$tag" --title "$tag" --notes "$release_notes"; then
                  echo "::warning::Failed to create GitHub release for $version"
                fi
              else
                echo "Release $tag already exists"
              fi
              published_versions="$published_versions $display_version"
            fi

            # Clean dist for next iteration
            rm -rf dist/

            echo "::endgroup::"
          done

          # Report results
          if [ -n "$published_versions" ]; then
            echo "Successfully published:$published_versions"
          fi

          if [ -n "$failed_versions" ]; then
            echo "failed_versions=$failed_versions" >> $GITHUB_OUTPUT
            echo "::error::Failed to publish versions:$failed_versions"
          fi

      - name: Check for failures
        if: always() && steps.publish.outputs.failed_versions != ''
        run: |
          echo "The following versions failed to publish: ${{ steps.publish.outputs.failed_versions }}"
          exit 1
